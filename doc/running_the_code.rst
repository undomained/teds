Running the code
====================

General remarks
---------------

YAML configuration files
++++++++++++++++++++++++

Each TEDS module takes one argument which is a reference to a configuration file written in YAML. We chose YAML because it is versatile, human-readable, and widely used and supported. It uses Python-style indentation to indicate nesting and as basic types supports scalars, lists, and maps (also called dictionaries or hashes). Furthermore, it is a strict superset of JSON and thus compatible with it.

A quick way to understand the YAML format is run the L1A-L1B C++ code without any arguments:

.. code-block:: bash

   <build>/tango_l1b.x

The output contains keywords showing their type, default value, and description. A YAML file may contain several sections. For instance, a ``detector`` section contains a set of parameters specifically targeting the detector.

The basic element of YAML is a key-value pair where the value is a scalar, list, or a map. Here is example YAML where the element type is noted as a comment::

  io: # starts a map
    l1a_files: # key followed by a list
      - l1a_1.nc # scalar
      - l1a_2.nc # scalar
  cal_level: l1a # key-value

There are many checks in the code which notify you of errors and inconsistencies in the configuration file. If you use a non-existent keyword the processor will issue a warning but will continue with the calculation.

Full specification of YAML and how to use it is found here: https://yaml.org/spec/1.2.2/.


NetCDF
++++++++

It is an objective of TEDS to only work with NetCDF files, either as input or output of any module. NetCDF is a self-documenting binary format, making it easy to read and manipulate the output of a given module before feeding it to the next module.

At the time of writing, some of the auxiliary files generated by TEDS are in Python's Pickle format. However, since these are not always portable they will be substituded with the NetCDF format soon.


Geometry module
------------------

The geometry module has a single driver function which takes a dictionary of user-defined parameters as input. Assuming TEDS is in your ``PYTHONPATH``, you can run it with

.. code-block:: python

   from teds.GM.gm import geometry_module
   import yaml
   conf = yaml.safe_load(open('gm.yaml'))
   geometry_module(conf)


Scene generation module
-------------------------



Instrument model
------------------

If the build process was successful, an executable called ``tango_l1b.x`` is produced in the build directory ``<build>``. The executable takes one argument which is the YAML file where you specify how to apply the CKD to the line-by-line spectra produced by the scene generation module in order to generate a L1A product:

.. code-block:: bash

   export OMP_NUM_THREADS=8
   <build>/tango_im.x im.yaml

If you exclude the ``export`` statement then the default is to run using all available threads. Both the instrument model and the L1A-L1B processor are parallelized over detector images.


L1A-L1B processor
------------------

The L1A-L1B processor runs just like the instrument model:

.. code-block:: bash

   export OMP_NUM_THREADS=8
   <build>/tango_l1b.x l1b.yaml


L1-L2 processor
---------------



L2-L4 processor
---------------
