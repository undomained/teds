# This source code is licensed under the 3-clause BSD license found in
# the LICENSE file in the root directory of this project.
from netCDF4 import Dataset
from scipy.interpolate import CubicSpline
from tqdm import tqdm
from xarray import DataArray
import numpy as np
import numpy.typing as npt
import os
import sys

from .atmosphere import Atmosphere
from .io import read_atmosphere_and_albedo
from .io import write_atmosphere
from .io import write_radiance
from .types import Gas
from .types import Meteo
from teds import log
from teds.gm import vincenty
from teds.gm.io import read_geometry
from teds.gm.types import Geometry
from teds.l1al1b.io import read_ckd
from teds.l1al1b.types import L1
from teds.l1al1b.types import ProcLevel
from teds.lib import radiative_transfer
from teds.lib.convolution import Kernel
from teds.lib.convolution import KernelGauss2D
from teds.lib.io import check_file_presence
from teds.lib.io import merge_config_with_default
from teds.lib.io import print_heading
from teds.lib.io import print_system_info
from teds.lib.surface import Surface

try:
    from teds_cpp.bindings import rt_act
except ModuleNotFoundError:
    def rt_act(co2_concentration: npt.NDArray[np.floating],
               ch4_concentration: npt.NDArray[np.floating],
               h2o_concentration: npt.NDArray[np.floating],
               co2_xsec: npt.NDArray[np.floating],
               ch4_xsec: npt.NDArray[np.floating],
               h2o_xsec: npt.NDArray[np.floating],
               albedo: npt.NDArray[np.floating],
               mu_sza: npt.NDArray[np.floating],
               mu_vza: npt.NDArray[np.floating],
               sun: npt.NDArray[np.floating],
               rad: npt.NDArray[np.floating]) -> None:
        log.error('no implementation: calling rt_act stub')
        sys.exit(1)


def check_config(config: dict) -> None:
    """Check consistency of some of the configuration settings.

    Parameters
    ----------
    config
        Path of YAML configuration file.

    """
    check_file_presence(config['io_files']['geometry'], 'geometry')
    check_file_presence(config['io_files']['atmosphere'], 'atmosphere')
    check_file_presence(config['io_files']['sun_reference'], 'sun_reference')
    if config['isrf']['enabled'] and config['isrf']['tabulated']:
        check_file_presence(config['io_files']['isrf'], 'ISRF')
    if config['alt_end']:
        config['alt_end'] += 1
    if config['io_files']['isrf_U'] and not config['sedf']['enabled']:
        log.error(f"If isrf_U ({config['io_files']['isrf_U']}) is present the "
                  "SEDF must be enabled (set [sedf][enabled] to true)")
        sys.exit(1)


def gen_sedf(config: dict, geometry: Geometry) -> KernelGauss2D:
    """Generate SEDF based on geometry and user settings.

    Parameters
    ----------
    config
        SEDF section of the configuration file
    geometry
        Extended geometry as generated by the GM. Used for getting the
        grid spacing.

    Returns
    -------
        2D generalized Gauss function representing the SEDF

    """
    def vincenty_deg(
            lat1: float, lat2: float, lon1: float, lon2: float) -> float:
        """Geodetical distance between two points given in degrees."""
        return vincenty(np.deg2rad(np.array([lat1])),
                        np.deg2rad(np.array([lat2])),
                        np.deg2rad(np.array([lon1])),
                        np.deg2rad(np.array([lon2])))[0]

    lat, lon = geometry.lat, geometry.lon
    dy = vincenty_deg(
        lat[0, 0], lat[-1, 0], lon[0, 0], lon[-1, 0]) / lat.shape[0]
    dx = vincenty_deg(
        lat[0, 0], lat[0, -1], lon[0, 0], lon[0, -1]) / lat.shape[1]
    dy_grid = config['fwhm_y'] / dy
    dx_grid = config['fwhm_x'] / dx
    return KernelGauss2D(
        dx_grid, dy_grid, config['shape_x'], config['shape_y'])


def build_hetero_isrf(U_filename: str,
                      albedo: npt.NDArray[np.floating],
                      bin_alt: int) -> DataArray:
    nc_U = Dataset(U_filename)
    U = nc_U['U'][::-1, :].data
    wavelengths = nc_U['wavelength'][:].data
    isrf = DataArray(np.empty(((albedo.shape[0]) // bin_alt,
                               albedo.shape[1], len(wavelengths))),
                     dims=('alt_bin', 'act_bin', 'wavelength'),
                     coords={'wavelength': wavelengths})
    for i_alt in tqdm(range(isrf.shape[0])):
        for i_act in range(isrf.shape[1]):
            albedo_alt_beg = i_alt * bin_alt
            albedo_alt_end = albedo_alt_beg + bin_alt
            albedo_slice = albedo[albedo_alt_beg:albedo_alt_end, i_act]
            indices = np.arange(0, len(albedo_slice), 1.0)
            indices_interp = np.linspace(
                0, len(albedo_slice)-1, len(wavelengths))
            albedo_interp = CubicSpline(indices, albedo_slice)(indices_interp)
            isrf[i_alt, i_act, :] = (albedo_interp * U).sum(axis=0)
            isrf[i_alt, i_act, :] /= isrf[i_alt, i_act, :].sum()
    return isrf


def reduce_alt_act_dimension(geometry: Geometry,
                             albedo: npt.NDArray[np.floating],
                             atm: Atmosphere,
                             alt_beg: int,
                             alt_end: int | None,
                             act_beg: int = 0,
                             act_end: int | None = None) -> None:
    """Reduce data dimension in both ALT and ACT dimension.

    Parameters
    ----------
    geometry
        Geometry
    albedo
        Sentinel 2 albedo band B11
    atm
        Atmosphere, including the gases

    """
    if not act_end:
        act_end = geometry.lat.shape[1]
    # Reduce geometry
    geometry.lat = geometry.lat[alt_beg:alt_end, act_beg:act_end]
    geometry.lon = geometry.lon[alt_beg:alt_end, act_beg:act_end]
    geometry.height = geometry.height[alt_beg:alt_end, act_beg:act_end]
    geometry.sza = geometry.sza[alt_beg:alt_end, act_beg:act_end]
    geometry.saa = geometry.saa[alt_beg:alt_end, act_beg:act_end]
    geometry.vza = geometry.vza[alt_beg:alt_end, act_beg:act_end]
    geometry.vaa = geometry.vaa[alt_beg:alt_end, act_beg:act_end]
    # Reduce albedo
    albedo_red = albedo[alt_beg:alt_end, act_beg:act_end]
    albedo.resize((albedo_red.shape), refcheck=False)
    albedo[:] = albedo_red
    # Reduce gases
    for gas in atm.gases:
        gas.concentration = gas.concentration[
            alt_beg:alt_end, act_beg:act_end, ...]
    atm.air = atm.air[alt_beg:alt_end, act_beg:act_end, ...]


def get_geometry_margins_and_multipliers(
        gm_filename: str, geometry_ext: Geometry) -> tuple[int, int, int, int]:
    """Get margins and density multipliers applied in GM.

    The GM generated two geometries: normal and an extended
    geometry. The latter is denser and contains points outside the
    target area so that convolutions could be performed correctly.

    Parameters
    ----------
    gm_filename
        File for read the geometry once more (this time the normal
        geometry).
    geometry_ext
        Extended geometry which is used throughout most of this
        module. Will also be reduced.

    Returns
    -------
        Margins, in units of pixels of the extended geometry, in ALT
        and ACT dimension and grid density multipliers in ALT and ACT
        dimension. Basically, these are the four parameters used in
        the extended_geometry section of a GM input file.

    """
    # Normal geometry is a subset of the extended geometry. Find the
    # position of a corner of the normal geometry in extended
    # geometry. The result is the coordinates of how far the normal
    # geometry is from the edges of extended geometry, i.e. the
    # margins.
    geometry = read_geometry(gm_filename)
    result = np.where(abs(geometry_ext.lat - geometry.lat[0, 0]) < 1e-10)
    m_alt = int(result[0])
    m_act = int(result[1])
    bin_alt = (geometry_ext.lat.shape[0] - 2 * m_alt) // geometry.lat.shape[0]
    bin_act = (geometry_ext.lat.shape[1] - 2 * m_act) // geometry.lat.shape[1]
    return m_alt, m_act, bin_alt, bin_act


def resample_alt_act(bin_alt: int,
                     bin_act: int,
                     atm: Atmosphere,
                     albedo: npt.NDArray[np.floating],
                     geometry: Geometry) -> tuple[Atmosphere,
                                                  list[DataArray],
                                                  Geometry]:
    """Resample arrays in both ALT and ACT dimensions.

    Because the data are already convolved we should not bin but
    instead resample to a coarser grid.

    Parameters
    ----------
    bin_alt
        Grid density multiplier use in the GM in the ALT direction.
    bin_act
        Grid density multiplier use in the GM in the ACT direction.
    geometry
        Extended geometry.
    albedo
        Sentinel 2 albedo band B11
    atm
        Atmosphere, including the gases

    """
    n_alt, n_act, n_lay = atm.get_gas('co2').concentration.shape
    n_alt_resamp = int(n_alt // bin_alt)
    n_act_resamp = int(n_act // bin_act)

    # Geometry
    geometry_resamp = Geometry.from_shape((n_alt_resamp, n_act_resamp))
    geometry_resamp.lat[:] = geometry.lat[::bin_alt, ::bin_act]
    geometry_resamp.lon[:] = geometry.lon[::bin_alt, ::bin_act]
    geometry_resamp.height[:] = geometry.height[::bin_alt, ::bin_act]
    geometry_resamp.sza[:] = geometry.sza[::bin_alt, ::bin_act]
    geometry_resamp.saa[:] = geometry.saa[::bin_alt, ::bin_act]
    geometry_resamp.vza[:] = geometry.vza[::bin_alt, ::bin_act]
    geometry_resamp.vaa[:] = geometry.vaa[::bin_alt, ::bin_act]

    # Atmosphere
    atm_resamp = Atmosphere.from_empty()
    atm_resamp.zlay = atm.zlay
    atm_resamp.zlev = atm.zlev
    for gas in atm.gases:
        atm_resamp.gases.append(Gas(gas.name,
                                    gas.source,
                                    gas.emission_in_kgps,
                                    gas.concentration[::bin_alt, ::bin_act]))
    atm_resamp.air = atm.air[::bin_alt, ::bin_act]

    # Albedo
    albedo_resamp = DataArray(albedo[::bin_alt, ::bin_act], dims=('y', 'x'))
    albedo_resamp.attrs['band_label'] = 'B11'
    albedo_resamp.attrs['central_wavelength'] = 1620
    albedo_resamp.attrs['bandwidth'] = '60'
    albedo_resamp.rio.write_crs('EPSG:4326', inplace=True)
    albedos_resamp = [albedo_resamp]
    return atm_resamp, albedos_resamp, geometry_resamp


def carbon_radiation_scene_generation(config_user: dict) -> None:
    """Generate TOA spectra for the Tango-Carbon instrument.

    The function has two parts. First defined the albedo and
    atmosphere. Second, perform the radiative transfer simulation on
    the grid provided by albedo and atmosphere.

    Parameters
    ----------
    config
        Configuration dictionary

    """
    print_heading('Tango radiation scene', empty_line=False)
    print_system_info()
    print(flush=True)

    config = merge_config_with_default(config_user, 'teds.sgm')
    check_config(config)

    atm, albedo = read_atmosphere_and_albedo(config['io_files']['atmosphere'])
    geometry = read_geometry(config['io_files']['geometry'], 'extended')

    # Get geometry margins and binning factors as set in the extended
    # section of GM configuration file.
    m_alt, m_act, bin_alt, bin_act = get_geometry_margins_and_multipliers(
        config['io_files']['geometry'], geometry)

    if geometry.lat.shape[0] > 1 and config['sedf']['enabled']:
        # Convolve the albedo and all relevant gases with the
        # instrument spatial response function SEDF.
        sedf = gen_sedf(config['sedf'], geometry)
        log.info('Convolving albedo with SEDF')
        albedo = sedf.convolve(albedo)
        for gas_name in ('co2', 'ch4', 'h2o'):
            log.info(f'Convolving {gas_name.upper()} with SEDF')
            gas = atm.get_gas(gas_name)
            for i_z in range(gas.concentration.shape[2]):
                gas.concentration[:, :, i_z] = sedf.convolve(
                    gas.concentration[:, :, i_z])
        for i_z in range(atm.air.shape[2]):
            atm.air[:, :, i_z] = sedf.convolve(atm.air[:, :, i_z])

    # Regardless of whether that data was convolved, reduce geometry
    # to cover just the target area, i.e. the margins are not required
    # anymore.
    n_alt, n_act = geometry.lat.shape
    reduce_alt_act_dimension(
        geometry, albedo, atm, m_alt, n_alt-m_alt, m_act, n_act-m_act)

    # Construct the heterogeneous ISRF if requested
    hetero_isrf = DataArray()
    if config['io_files']['isrf_U']:
        log.info('Generating heterogeneous ISRF')
        hetero_isrf = build_hetero_isrf(
            config['io_files']['isrf_U'], albedo, bin_alt)

    # Also bin the data to normal geometry size
    atm, albedos, geometry = resample_alt_act(
        bin_alt, bin_act, atm, albedo, geometry)
    albedo = 1.0 * albedos[0].data  # need a deep copy

    # Work with an ALT slice if requested by the user
    reduce_alt_act_dimension(
        geometry, albedo, atm, config['alt_beg'], config['alt_end'])

    log.info('Saving reference atmosphere (binned)')
    atm_binned, albedos_binned, geometry_binned = resample_alt_act(
        config['bin_alt'], config['bin_act'], atm, albedo, geometry)
    # Meteorological data (nothing to do here)
    meteo = Meteo.from_empty()
    write_atmosphere(config['io_files']['atmosphere_ref'],
                     atm_binned,
                     meteo,
                     albedos_binned,
                     geometry_binned)

    # Independently from config['sedf']['enabled'] we have atmospheric
    # data and geometry on the same grid. For the dataset atm, albedo,
    # geometry, we perform the RT simulation.

    # Line-by-line spectral grid
    wave_start = config['spec_lbl_settings']['wave_start']
    wave_end = config['spec_lbl_settings']['wave_end']
    dwave_lbl = config['spec_lbl_settings']['dwave']
    wave_lbl = np.arange(wave_start, wave_end, dwave_lbl)  # nm

    # Online calculation of cross section or retrieving data from
    # dummy file depending on config. To save time, a NetCDF dump file
    # may be used.
    optics = radiative_transfer.OpticAbsProp(wave_lbl, atm.zlay)
    if (
            not os.path.exists(config['io_files']['dump_xsec'])
            or config['xsec_forced']):
        # See hapi manual Sec 6.6
        iso_ids = [('CH4', 32), ('H2O', 1), ('CO2', 7)]
        molec = radiative_transfer.MolecularData(
            wave_lbl, config['io_files']['hapi'], iso_ids)
        atm_ref = Atmosphere.from_file(
            atm.zlay,
            atm.zlev,
            config['atmosphere']['surface_pressure'],
            config['io_files']['afgl'])
        # Molecular absorption optical properties
        optics.calc_molec_xsec(molec, atm_ref)
        optics.xsec_to_file(config['io_files']['dump_xsec'])
    else:
        optics.xsec_from_file(config['io_files']['dump_xsec'])

    # Next we perform the RT simuations for the generated input
    n_alt, n_act = geometry.sza.shape
    n_lbl = wave_lbl.size

    # Solar irradiance spectrum
    sun_wavelengths, sun_spectrum = (
        radiative_transfer.read_sun_spectrum_TSIS1HSRS(
            config['io_files']['sun_reference']))
    sun = np.interp(wave_lbl, sun_wavelengths, sun_spectrum)
    # Calculate surface data
    surface = Surface(wave_lbl)
    # For output we use the level 1 data product class because it has
    # all the variable we need.
    rad_output = L1.from_empty()
    rad_output.geometry = geometry

    log.info('Radiative transfer simulation')

    if config['isrf']['enabled']:
        # Line-by-line simulations with subsquently ISRF convolution
        # (line-by-line spectra not kept in memory).
        ckd = read_ckd(config['io_files']['ckd'])
        rad_output.wavelengths = ckd.spectral.wavelengths
        if config['isrf']['tabulated']:
            isrf = Kernel.from_file(
                config['io_files']['isrf'], wave_lbl, rad_output.wavelengths)
        else:
            isrf = Kernel.from_gauss(wave_lbl,
                                     ckd.spectral.wavelengths,
                                     config['isrf']['fwhm'],
                                     config['isrf']['shape'])
        # Function for ISRF convolution
        config['isrf']['type'] = 'Gaussian'
        # Convolved solar spectrum
        rad_output.solar_irradiance = isrf.convolve(sun)
        rad_output.spectra = np.empty(
            (n_alt, n_act, rad_output.wavelengths.size))
        rad_output.proc_level = ProcLevel.l1b
    else:
        # Line-by-line spectra stored in the output file
        rad_output.spectra = np.empty((n_alt, n_act, n_lbl))
        rad_output.wavelengths = wave_lbl
        rad_output.solar_irradiance = sun
        rad_output.proc_level = ProcLevel.sgm

    # Line-by-line radiances for one scan-line
    radiance_lbl = np.empty([n_act, n_lbl])
    for i_alt in tqdm(range(n_alt)):
        if not config['isrf']['enabled']:
            radiance_lbl = rad_output.spectra[i_alt, :, :]
        if config['use_python_radiative_transfer']:
            for i_act in range(n_act):
                # Atmosphere for one target point (i_alt, i_act)
                atm_p = Atmosphere.from_empty()

                def copy_gas_one_column(gas_name: str) -> Gas:
                    return Gas(
                        gas_name,
                        None,
                        None,
                        atm.get_gas(gas_name).concentration[i_alt, i_act, :])

                atm_p.gases = [copy_gas_one_column('co2'),
                               copy_gas_one_column('ch4'),
                               copy_gas_one_column('h2o')]
                # Calculate optical depths
                optics.set_opt_depth_species(atm_p, ['H2O', 'CH4', 'CO2'])
                # Earth radiance spectra
                alb = [albedo[i_alt, i_act]]
                mu_sza = np.cos(np.deg2rad(geometry.sza[i_alt, i_act]))
                mu_vza = np.cos(np.deg2rad(geometry.vza[i_alt, i_act]))
                surface.get_albedo_poly(alb)
                radiance_lbl[i_act, :] = radiative_transfer.transmission(
                    sun, optics, surface.alb, mu_sza, mu_vza)
        else:
            rt_act(atm.get_gas('co2').concentration[i_alt, :, :],
                   atm.get_gas('ch4').concentration[i_alt, :, :],
                   atm.get_gas('h2o').concentration[i_alt, :, :],
                   optics.get_prop('CO2').xsec,
                   optics.get_prop('CH4').xsec,
                   optics.get_prop('H2O').xsec,
                   albedo[i_alt, :],
                   np.cos(np.deg2rad(geometry.sza[i_alt, :])),
                   np.cos(np.deg2rad(geometry.vza[i_alt, :])),
                   sun,
                   radiance_lbl)
        if config['isrf']['enabled']:
            for i_act in range(n_act):
                rad_output.spectra[i_alt, i_act, :] = isrf.convolve(
                    radiance_lbl[i_act, :])

    log.info('Writing output')
    write_radiance(
        config['io_files']['radiance'], config, rad_output, hetero_isrf)

    print_heading('Success')
